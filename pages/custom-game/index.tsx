import Head from "next/head";
import Navbar from "../components/navbar";
import Footer from "../components/footer";
import ProjectBanner from "../components/projects/projectBanner";
import ShowcaseSection from "../components/projects/showcaseSection";
import ProjectTechStack from "../components/projects/projectTechStack";
import InfoSectionPrimary from "../components/projects/infoSectionPrimary";
import InfoSectionSecondary from "../components/projects/infoSectionSecondary";

import Image from "next/image";
import st from "../../public/assets/images/stripes.svg";
import sq from "../../public/assets/images/square.svg";
import sc from "../../public/assets/images/scribble.svg";

import graph from "../../public/assets/images/graph.svg";
import command from "../../public/assets/images/commands.svg";
import state from "../../public/assets/images/states.svg";
import composite from "../../public/assets/images/composite.svg";
import component from "../../public/assets/images/component.svg";

export default function Project() {
  const techStack = ["cplusplus"];

  return (
    <div>
      <Head>
        <title>James Vovos - Custom Game</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className="bg-hintedwhite-50 px-10 relative overflow-hidden">
        {/* Change these to only be pages (refactor components to only be components later) */}
        <section className="min-h-screen">
          <Navbar />
          <div>
            <span className="square">
              <Image
                src={sq}
                alt="Square"
                className="square absolute overflow-hidden"
              />
            </span>
            <span className="stripes">
              <Image
                src={st}
                alt="Stripes"
                className="stripes absolute overflow-hidden"
              />
            </span>
            <ProjectBanner
              title="CUSTOM GAME"
              desc="Custom game project showcasing the implementation of different software design patterns and data structures built in C++. This includes the state, composite, component, command and factory design patterns, as well as a graph/node data structure to represent the game world with different locations with adjacent location nodes."
              video="https://youtu.be/yAHBWlFMhCU"
            />
            <ProjectTechStack techStack={techStack} />
            <ShowcaseSection
              title="GAME DESIGN"
              desc="The game utilised graph and node data structures to represent the game world and locations. Each location has a list of adjacent nodes (or locations they can travel/traverse to). Different software design patterns were applied to the architecture of the game (which was built using a graphics library called Raylib and C++)."
              image={graph}
            />
            <span className="scribble">
              <Image
                src={sc}
                alt="Scribble"
                className="scribble absolute overflow-hidden"
              />
            </span>
            <InfoSectionSecondary
              title="COMMAND PATTERN"
              desc="The command pattern is utilised to handle/invoke commands in my game. This
              allows us to abstract out the 'command request' as a standalone object. Which means we can
              have different commands that follow their own method of execution(). These commands can
              be invoked via a 'CommandProcessor'. Each command will have their own receiver (or
              controller) in which can choose which commands it wants to run (in this case the receiver is
              our Player class)"
              image={command}
            />
            <InfoSectionPrimary
              title="COMPOSITE PATTERN"
              desc="The composite pattern is utilised to handle entities/items in our game world. This
              allows us to treat a group of objects in a similar way to a single object. For example: if we take
              the example of a “backpack”... Well, a backpack can contain “items” such as a “sword” a
              “potion”... But it may also contain items that group a collection of items. Think of a “wallet”
              that can be put in a backpack that can hold coins, credit cards, etc.
              How we handle both the 'composite' of items and a 'singular' item should be handled in a
              singular way."
              image={composite}
            />
            <InfoSectionSecondary
              title="STATE PATTERN"
              desc=" The state pattern is utilised to handle changes between different 'menu' states within my custom project. This utilises a 'GameManager' which managers the changes between different states on the stack. Different states include the 'MainMenu', 'Gameplay', 'QuitGame', 'About', etc (which have their own update() and render() functions which can be called in our main game loop/window)."
              image={state}
            />
            <InfoSectionPrimary
              title="COMPONENT PATTERN"
              desc="The component pattern is utilised to avoid deep nested trees of inheritance in our
              game design. Instead of giving our 'enemy' or 'player' class (as examples), variables to their
              health, mana or attack attributes we decoupled our code by aiming to give our entities a
              bunch of 'attributes' and 'actions' objects which can be stored in a dictionary/map in the
              classes that need them."
              image={component}
            />
          </div>
          <div>
            <Footer />
          </div>
        </section>
      </main>
    </div>
  );
}
